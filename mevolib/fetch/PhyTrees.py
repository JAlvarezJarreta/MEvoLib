#-------------------------------------------------------------------------------
#
#   MEvoLib  Copyright (C) 2016  J. Alvarez-Jarreta
#
#   This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
#   This is free software, and you are welcome to redistribute it under certain
#   conditions; type `show c' for details.
#
#-------------------------------------------------------------------------------
# File :  PhyTrees.py
# Last version :  v1.02 ( 17/Jul/2016 )
# Description :  Definition and implementation of the class 'PhyTrees'.
#-------------------------------------------------------------------------------
# Historical report :
#
#   DATE :  17/Jul/2016
#   VERSION :  v1.02
#   AUTHOR(s) :  J. Alvarez-Jarreta
#   CHANGES :  * Minor bugs fixed.
#
#   DATE :  16/Jul/2016
#   VERSION :  v1.01
#   AUTHOR(s) :  J. Alvarez-Jarreta
#   CHANGES :  * Fixed several documentation errors.
#
#   DATE :  26/Nov/2015
#   VERSION :  v1.00
#   AUTHOR(s) :  J. Alvarez-Jarreta
#
#-------------------------------------------------------------------------------

from __future__ import absolute_import
from __future__ import annotations

import os
import sys
from datetime import datetime
import errno
import operator
from pathlib import Path

from Bio import Phylo


#-------------------------------------------------------------------------------

class PhyTrees :
    """
    A PhyTrees object holds Tree objects (Bio.Phylo from Biopython) and
    information about their source.
    
    Attributes :
        data  ( list )
            List where the Tree objects are stored.
        _report  ( Private[list] )
            List of tuples with the information of the source or sources of the
            Tree objects stored at 'data'. This information is handled
            internally and shouldn't be modified externally in any way.

    Examples :

        Even though the user can create a PhyTrees object by hand, there are two
        main methods provided to make things easier:
        
        >>> from MEvoLib.PhyTrees import PhyTrees
        >>> treesdb = PhyTrees.from_treefile('trees.newick', 'newick')
        >>> print(treesdb)
        Num. trees: 5
        History:
        2015/11/26 10:24:05    /home/usr1/trees.newick    newick

        >>> phytreesdb = PhyTrees.from_phytrees('phytreesfile.newick')
        >>> print(phytreesdb)
        Num. trees: 2
        History:
        2015/11/26 10:27:42    /home/usr1/old_trees.newick    newick
        
        The user can also get several statistics (number of trees, and mean,
        minimum and maximum number of leaves) about the stored data:
        
        >>> len(phytreesdb)
        2
        >>> phytreesdb.statistics()
        (2, 15.0, 10, 20)
        
        The database can be updated by joining two PhyTrees objects:
        
        >>> len(treesdb)
        5
        >>> treesdb.join(phytreesdb)
        >>> len(treesdb)
        7
        
        Or including a new tree file:

        >>> len(phytreesdb)
        2
        >>> phytreesdb.include('trees.newick', 'newick')
        >>> len(phytreesdb)
        7
        
        Finally, all the information can be saved in two files, one with the
        Tree objects (in newick format) and the other one with the information
        in the '_report' list:
        
        >>> treesdb.write('new_trees.newick')
        
    """

    def __init__ ( self, tree_list, report ) :
        """
        Create a PhyTrees object with 'tree_list' and 'report' information.

        Arguments :
            tree_list  ( list )
                List of trees.
            report  ( list )
                Historical report of the tree information.
        """
        self.data = tree_list
        self._report = report



    @classmethod
    def from_phytrees ( cls, phytrees_file ) :
        """
        Create a PhyTrees object retrieving all the information from previously
        saved PhyTrees tree and report files. If 'phytrees_file' contains a
        relative path, the current working directory will be used to get the
        absolute path.
        
        Arguments :
            phytrees_file  ( string )
                Tree file generated by PhyTrees.write().

        Raises :
            ValueError
                If the number of trees read doesn't match the number stored in
                the report document.
        """
        data_filepath = Path(phytrees_file).resolve()
        report_filepath = os.path.splitext(data_filepath)[0] + '.rep'
        # Load all the contents into a new PhyTrees object
        tree_list = list(Phylo.parse(data_filepath, 'newick'))
        report = []
        with open(report_filepath, 'r') as report_file :
            str_num_trees = report_file.readline()
            num_trees = int(str_num_trees.split(':')[-1])
            if ( len(tree_list) != num_trees ) :
                message = 'The number of trees at report file doesn\'t match ' \
                          'the number of trees loaded'
                raise ValueError(message)
            # Ignore "History:" line
            report_file.readline()
            for line in report_file.readlines() :
                date_time, filepath, fileformat = line.strip().split('    ')
                report.append((date_time, filepath, fileformat))
        return ( cls(tree_list, report) )



    @classmethod
    def from_treefile ( cls, treefile, fileformat ) :
        """
        Create a PhyTrees object retrieving all the information stored at the
        tree file provided. If 'treefile' contains a relative path, the current
        working directory will be used to get the absolute path.
        
        Arguments :
            treefile  ( string )
                Input tree file.
            fileformat  ( string ) 
                Input file format.

        Raises :
            IOError
                If the path or the file provided doesn't exist.

        * The file format must be supported by Bio.Phylo.
        * If the file format provided doesn't correspond to the actual file
        format, an empty tree list will be created.
        """
        filepath = Path(treefile).resolve()
        # Read the tree file and create a new PhyTrees object, generating a new
        # report list
        tree_list = list(Phylo.parse(filepath, fileformat))
        date_time = datetime.now().strftime('%Y/%m/%d %H:%M:%S')
        report = [(date_time, filepath, fileformat)]
        return ( cls(tree_list, report) )



    def __len__ ( self ) :
        """
        Returns :
            int
                Total number of trees.
        """
        return ( len(self.data) )



    def __str__ ( self ) :
        """
        Returns :
            string
                Fancy print of the data stored in the PhyTrees object.
        """
        output = 'Num. trees: {:d}\nHistory:\n'.format(len(self))
        output += '\n'.join(['    '.join(x)  for x in self._report])
        return ( output )



    def include ( self, treefile, fileformat ) :
        """
        Add the information of the tree file to the PhyTrees object. All trees
        (old and new ones) will be considered as different.
        
        Arguments :
            treefile  ( string )
                Input tree file.
            fileformat  ( string ) 
                Input file format.

        Raises :
            IOError
                If the path or the file provided doesn't exist.

        * The file format must be supported by Bio.Phylo.
        * If the file format provided doesn't correspond to the actual file
        format, nothing will be added.
        """
        new_phytrees = PhyTrees.from_treefile(treefile, fileformat)
        self.data.extend(new_phytrees.data)
        self._report.extend(new_phytrees._report)



    def join ( self, new_phytrees ) :
        """
        Join the information of the PhyTrees object with another PhyTrees
        object. All trees (old and new ones) will be considered as different.
        
        Arguments :
            new_phytrees  ( PhyTrees )
                The external PhyTrees object.
        """
        self.data.extend(new_phytrees.data)
        self._report.extend(new_phytrees._report)
        self._report.sort(key=operator.itemgetter(0))



    def write ( self, phytrees_file ) :
        """
        Save all trees stored at the PhyTrees object in the 'phytrees_file' (in
        newick format). A file with a detailed report of the trees will be
        created replacing the extension of 'phytrees_file' by ".rep". If
        'phytrees_file' contains a relative path, the current working directory
        will be used to get the absolute path. If any file already exists, it
        will be overwritten without warning.
        
        Arguments :
            phytrees_file  ( string )
                New PhyTrees tree file.

        Raises :
            IOError
                If the path provided doesn't exist.
        """
        data_filepath = Path(phytrees_file).resolve()
        report_filepath = os.path.splitext(data_filepath)[0] + '.rep'
        # Generate a single string with all the report content
        str_report = '\n'.join(['    '.join(x)  for x in self._report])
        # Write all the information in the PhyTrees files
        try :
            Phylo.write(self.data, data_filepath, 'newick')
            with open(report_filepath, 'w') as report_file :
                report_file.write('Num. trees: {:d}\nHistory:\n' \
                                  '{:s}'.format(len(self), str_report))
        except IOError :
            raise
        except :
            if ( os.path.isfile(data_filepath) ) :
                os.remove(data_filepath)
            if ( os.path.isfile(report_filepath) ) :
                os.remove(report_filepath)
            raise



    def statistics ( self ) :
        """
        Calculate the total number of trees stored and the mean, minimum and
        maximum values of their leaves.
        
        Returns :
            int
                Total number of trees.
            float
                Mean tree leaves.
            int
                Minimum tree leaves.
            int
                Maximum tree leaves.

        """
        mean = 0.0
        minmax = [sys.maxint, 0]        
        for tree in self.data :
            leaves = tree.count_terminals()
            mean += leaves
            if ( minmax[0] > leaves ) :
                minmax[0] = leaves
            if ( minmax[1] < leaves ) :
                minmax[1] = leaves
        mean = mean / len(self)
        return ( len(self), mean, minmax[0], minmax[1] )


#-------------------------------------------------------------------------------
